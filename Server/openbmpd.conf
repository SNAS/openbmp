# Yaml 1.2 supported - http://yaml.org
---

# NOTE: By default, this configuration file is not loaded unless you specify the
#       commandline option "-c <configuration filename>"  This is to ensure
#       backwards compatibility with the shell commandline options.
#       If you are using this configuration file, then the init script (/etc/default/openbmpd)
#       can be updated to only include the -c <config file> option.  Remove the others.

base:
  # Admin id for this collector - Use "hostname" to use the system hostname
  #    Can be any string value up to 64 bytes
  admin_id: hostname

  # BMP server listening port
  listen_port: 5000

  # IPv4/IPv6 mode setting
  #    Can be "v4" "v6" or "v4v6"
  listen_mode: v4

  buffers:
    # Size in MBytes
    # Each router is allocated this buffer size.  This is a blocking circular buffer,
    #    which eliminates any read/processing delay by the collector.
    #    A size of 8MB is sufficient for a few peers.   Use 64 if the router
    #    is a route reflector or large transit peering router.
    #
    # NOTE:  In the future there will be two buffers, min and max, that will be used
    #        by the collector to dynamically grow based on blocking hits.
    #
    # Default is 5, range is 2 - 384
    router: 15

  heartbeat:
    # In minutes; Collector heartbeat messages will be generated based on this interval.
    #    Heatbeat messages are sent every interval, unless there was a change event sent witin the interval.
    #    Consumers monitor/track this in order to detect if the collector and associated routers/peers are
    #    up or not.
    #
    #    Default is 5.
    interval: 5


debug:
  general: false       # General debugging
  bmp:     false       # BMP related
  bgp:     false       # BGP related
  msgbus:  false       # Kafka/message bus - this will enable librdkafka debugging as well


kafka:
  # Broker list.  IPv6 works with optional :port.   Can specify the protocol using <proto>://<host>[:port]
  brokers:
    - localhost:9092

  # Topics are the topic names used by the collector when producing messages.
  #   You can customize each topic, including using variable substitution.
  #
  #   mapping.groups.* can be used as variables.
  #   E.g. unicast_prefix: "{root}.{parsed}.{router_group}.{peer_group}.unicast_prefix"
  #
  #   Global/system variables will be replaced at runtime based on mappings and content.
  #
  # NOTE: If you define a system variable (e.g. router_group, peer_group, ...) and there is no match,
  #        "default" will be used in its place.
  topics:

      # Global/System variables
      #     {router_group}  - See mapping.router_group
      #     {peer_group}    - See mapping.peer_group
      #
      #   Below are variables that should be used with caution becuase additional memory will be used to track the topics
      #
      #     {peer_asn}      - Peer ASN (remote peer ASN)
      #

      # Define variables - also see mappings for variables
      #   You should use simple ascii strings with no spaces for the variables used in topic mapping
      variables:
        root:   "openbmp"   # Defines the root topic (e.g. openbmp.*)
        raw:    "bmp_raw"   # Defines the name for bmp raw messages (e.g. openbmp.bmp_raw.*)
        parsed: "parsed"    # Defines the name for parsed messages (e.g. openbmp.parsed.*)

      #  Define the topic names
      names:
        # collector messages are not by router or group, so those group mappings should not be used
        collector:      "{root}.{parsed}.collector"

        # router messages are not by peer or group, so peer group mapping should not be used
        router:         "{root}.{parsed}.{router_group}.router"

        # The below support group mappings router_group and peer_group, and peer_asn
        peer:           "{root}.{parsed}.{router_group}.{peer_group}.peer"
        bmp_stat:       "{root}.{parsed}.{router_group}.{peer_group}.bmp_stat"
        bmp_raw:        "{root}.{router_group}.{peer_group}.{raw}"
        base_attribute: "{root}.{parsed}.{router_group}.{peer_group}.base_attribute"
        unicast_prefix: "{root}.{parsed}.{router_group}.{peer_group}.{peer_asn}.unicast_prefix"
        ls_node:        "{root}.{parsed}.{router_group}.{peer_group}.ls_node"
        ls_link:        "{root}.{parsed}.{router_group}.{peer_group}.ls_link"
        ls_prefix:      "{root}.{parsed}.{router_group}.{peer_group}.ls_prefix"

mapping:
  groups:
    # Order of matching
    #    Matching order is performed in the following sequence. The first match found is used.
    #
    #    regexp_hostname - Hostname/regular expression is used first
    #    prefix_range    - Prefix range is used second
    #    asn             - Peer asn list

    # {router_group} is the variable that you use for topic substitution
    router_group:
      # name defines the value that is substituted for the variable.  This provides a consistent
      #    mapping for different IP's and hostnames
      - name: "phil-cran"

        # You can define a list of regexp's that match for hostname to group mapping
        regexp_hostname:
           - .*\.phil\..*

        # You can also define a list of prefixes that match for ip to group mapping
        prefix_range:
           - 10.100.100.0/24
           - 10.100.104.0/24
           - "2001:420:305c:100::/64"

    peer_group:
      # name defines the value that is substituted for the variable.  This provides a consistent
      #    mapping for different IP's and hostnames
      - name: "lab"

        # You can define a list of regexp's that match for hostname to group mapping
        regexp_hostname:
           - .*\.lab\..*

        # You can also define a list of prefixes that match for ip to group mapping
        prefix_range:
           - 10.100.100.0/24
           - 10.100.104.0/24

        # You can define the matching to look at the peer asn.  This is only available for peer_groups.
        asn:
          - 100
          - 65000
          - 65001
